# 1차원 배열

배열은 하나의 변수로 여러 개의 메모리를 사용하는 구조로서 "자료형" "배열 이름" "\[배열 크기\]"로 선언이 가능 하다.

for \(int i = 0 ; i &lt; 10; i++\){

arr\[i\] = 0;

}

위와 같은 코드로 초기화를 할 수 있다. 그리고 이 배열은 변수와 마찬가지로 전역변수 배열이 있고 지역 변수 배열이 존재한다.

전역변수 배열은 자동으로 0으로 초기화된다. 그리고 모든 변수는 전역 변수로 선언 하면 컴파일러에 의해 0으로 초기화된다.

하지만 지역변수는 자동으로 초기화 되지 않는다. 출력 결과에 쓰레기 값이 출력되는 것을 확인 할수 있다.

![](/assets/13-1.png)

![](/assets/13-2.png)배열을 사용할 때 발생하는 오류의 대부분은 배열의 범위를 벗어나서 사용하려는 시도 때문이다.

배열을 선언하고 배열의 범위를 벗어난 곳의 위치도 접근 할수는 있다.

배열끼리 복사할 때 배열을 한꺼번에 복사할수 없다.

![](/assets/13-3.png)

이런 경우 컴파일 오류가 발생한다.

# 1차원 배열을 함수의 파라미터로 전달

이전까지 파라미터를 주로 call by value로 복사하고 값을 전달 했다. 하지만 데이터가 많아진다면 복사하는 양도 많아지고 컴퓨터에 많은 부하가

걸릴 수도 있다. 자바나 다른 언어들은 사실 call by value의 형태로 값을 전달한다. 이것은 자바에 있는 가상머신이 자동으로 주소값에 값을 연결해서

사용자가 주소값을 일일히 호출하지 않아도 성립된다. 하지만 C언어는 다소 다른 면이 존재한다.

C언어는 고급 언어와 저급 언어가 공존한다. 이 언어에서는 주소값으로 다른 곳에 있는 변수들을 연결시킬수 있다.  특히 배열에서는 배열의 이름이

배열의 시작 주소가 되어 배열을 함수의 파라미터로 넘겨줄 때 배열을 복사해서 넘겨주는 것이 아니라 배열의 시작 주소를 넘겨준다.

이를  Call by reference라고 한다.

![](/assets/13-4.png)

addTen이라는 함수를 호출 할 때 data라는 함수의 이름을 붙여서 넣으면 배열의 가장 앞에 있는

값이 addTen\(\)함수로 전달된다. 그리하여 int  a\[\] 배열에 data \[\]의 주소값이 넣어진다.

# 1차원 벽돌깨기

1차원 벽돌 깨기에서 가장 핵심은 brick배열을 선언하고 공이 충돌 한 벽돌들은 0을 넣고 충돌 안한 벽돌들은  1을 넣는 것이 중요하다.

아래 그림을 보면 충돌 한 벽돌 들을 0으로 표현하고 방향을 전환하였다. 



![](/assets/13-5.png)![](/assets/13-6.png)



